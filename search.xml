<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>408错题</title>
    <url>/2023/05/22/408%E9%94%99%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<p>https://www.nowcoder.com/questionTerminal/2d29e10308f44ec686f482e224d29fed</p>
<p>https://blog.csdn.net/weixin_45697774/article/details/106853306?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168113314916800217250586%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168113314916800217250586&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>top_positive~default-1-106853306-null-null.142</p>
<h1 id="数据结构">数据结构</h1>
<h2 id="绪论">绪论</h2>
<h3 id="数据结构的基本概念">数据结构的基本概念</h3>
<ol type="1">
<li></li>
</ol>
<p><strong>抽象数据类型ADT=（数据对象，数据关系，基本操作集）</strong></p>
<p><strong>数据对象：相同性质的数据元素的集合</strong></p>
<p><strong>数据关系：数据元素之间的关系</strong></p>
<ol start="2" type="1">
<li></li>
</ol>
<p>线性结构特点：</p>
<p>数据元素存在一对一的数据关系，二维数组和多维数组不是线性结构因为a[0]一对多</p>
<ol start="3" type="1">
<li></li>
</ol>
<p>有序表：元素递增或递减的线性表</p>
<ol start="4" type="1">
<li></li>
</ol>
<p>逻辑结构是数学模型，未确定具体实现，循环队列为顺序存储</p>
<ol start="5" type="1">
<li></li>
</ol>
<ul>
<li><strong>逻辑结构与数据存储无关，逻辑结构有两个要素：数据元素、关系（通常要求同一逻辑结构中的所有数据元素具有相同的特性）</strong></li>
<li>存储结构要存储数据元素的数据</li>
<li>同一逻辑结构可有不同的存储结构</li>
<li><strong>数据结构三要素：逻辑结构、存储结构、数据运算</strong></li>
</ul>
<ol start="6" type="1">
<li></li>
</ol>
<p>ADT=（数据对象，数据关系，基本操作集）。数据对象和数据关系合起来叫做数据。</p>
<p>数据同基本操作集构成了ADT，因此ADT反映了数据结构的逻辑结构 + 运算。</p>
<p>重点：</p>
<p><strong>抽象数据类型ADT=（数据对象，数据关系，基本操作集）</strong></p>
<p><strong>数据结构三要素：逻辑结构、存储结构、数据运算</strong></p>
<p><strong>逻辑结构：数据元素、关系</strong></p>
<p>综合：</p>
<p>01：https://blog.csdn.net/AnthonyM08/article/details/108601001</p>
<h3 id="补充">补充：</h3>
<p>逻辑结构：集合、线性、树、图</p>
<p>集合：元素属于同一集合</p>
<p>线性：数据元素之间存在一对一的关系</p>
<p>树：数据元素之间存在一对多的关系</p>
<p>图：据元素之间存在多对多的关系</p>
<figure>
<img src="https://gitee.com/cj2564686478/note-img/raw/master/Img_Typora/202304092002635.png" alt="image-20230409200246480" /><figcaption aria-hidden="true">image-20230409200246480</figcaption>
</figure>
<p>字符串（也是特殊的线性表，其特殊性表现在它的数据元素仅由一个字符组成）</p>
<p>数据对象中的相同数据类型是指：不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致，因此所占的存储空间大小一样。</p>
<p>逻辑结构指出运算功能，存储结构指出运算的具体实现步骤。</p>
<h3 id="算法和算法评价">算法和算法评价</h3>
<ol type="1">
<li></li>
</ol>
<p>算法：是为了解决某类问题而规定的一个有限长的操作序列。</p>
<p>程序：程序=数据结构 + 算法</p>
<ol start="2" type="1">
<li></li>
</ol>
<p>时间复杂度$T( n ) =O( f( n ) ) =O( n^2 ) $，其中n为问题规模（求解问题的输入量），f（n）为，O表示f（n）的数量级.</p>
<p>一个算法的执行时间大致等于其所有语句执行时间的总和，而语句的执行时间则为该条语句的重复执行次数和执行一次所需时间的乘积。一条语句的重复执行次数称作语句频度（Frequency Count）。</p>
<p><strong>设每条语句执行一次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有语句频度之和来度量。</strong></p>
<p>但对于稍微复杂一些的算法，则通常是比较困难的，即便能够给出，也可能是个非常复杂的函数。因此，<strong>为了客观地反映一个算法的执行时间，可以只用算法中的“基本语句“的执行次数来度量算法的工作量。所谓“基本语句”指的是算法中重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大。（假设每条语句执行单位时间，频度越大，执行时间越多。f（n）为最大频度语句的阶数，当n趋于无穷大时，f（n）与重复执行最多次的语句频度成正比，系数为k。）</strong> <span class="math display">\[
\begin{aligned}
    \text{总时间}&amp;=\text{语句频度}*\text{每条语句执行时间}\\
    &amp;=\text{语句频度}*\text{单位时间}\\
    &amp;=\text{基本语句频度}*\text{单位时间}\\
    &amp;=\text{基本语句频度}\\
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\text{总时间}=Cf\left( n \right) \text{，}f\left( n \right) \text{为基本语句频度}
\\
\text{时间复杂度}T\left( n \right) =O\left( f\left( n \right) \right) \text{，时间复杂度为基本语句频度的阶数}
\\
\]</span></p>
<ol start="5" type="1">
<li></li>
</ol>
<p><span class="math display">\[
\underset{i=2}{\overset{n-1}{\varSigma}}\underset{j=1}{\overset{i-1}{\varSigma 1}}
\]</span></p>
<ol start="6" type="1">
<li></li>
</ol>
<p><span class="math display">\[
\underset{i=1}{\overset{n}{\varSigma}}\underset{j=1}{\overset{2i}{\varSigma 1}}
\]</span></p>
<ol start="10" type="1">
<li></li>
</ol>
<p>外层循环和内层循环无关，采用乘法规则</p>
<ol start="13" type="1">
<li></li>
</ol>
<p>最外层i的取值：1，2，4，8，...，n</p>
<p>最里层j的取值：i</p>
<p>执行总次数：1+2+4+...+n，累加次数为<span class="math inline">\(\log _2n\)</span></p>
<p>因此： <span class="math display">\[
S=\frac{a_1\left( 1-q^n \right)}{1-q}=\frac{1\left( 1-2^{\log _2n} \right)}{1-2}=n-1
\]</span> 综合题：</p>
<ol type="1">
<li></li>
</ol>
<p><span class="math display">\[
T\left( n \right) \begin{cases}
    1,n=1\\
    2T\left( \frac{n}{2} \right) +n,n&gt;1\\
\end{cases}
\]</span></p>
<p>需要注意的是n&gt;1时，递推关系式中的n是一次时间复杂度为n的操作，并不是加上一个数值n。</p>
<p>采用递推关系式得出： <span class="math display">\[
T\left( n \right) =\log _2nT\left( 1 \right) +n\log _2n=\log _2n\left( 1+n \right)
\]</span> 所以时间复杂度为<span class="math inline">\(n\log _2n\)</span>，执行次数为<span class="math inline">\(\log _2n\)</span>，每次执行一次时间复杂度为n的代码。</p>
<p>总结：</p>
<ol type="1">
<li>总时间是基本语句频度</li>
<li>计算时间复杂度下列几种方法：
<ul>
<li>列出执行次数与n的不等式（内外有关，非线性增加）</li>
<li>列出求和公式（内外有关，且线性增加）</li>
<li>乘法（内外无关）和加法规则</li>
<li>列出递归表达式（简单的不用列）</li>
</ul></li>
<li>递归是典型的空间换时间</li>
</ol>
<h3 id="补充-1">补充</h3>
<p>https://blog.csdn.net/kyle1314608/article/details/105505400?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168105250316800215094566%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168105250316800215094566&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>first_rank_ecpm_v1~rank_v31_ecpm-6-105505400-null-null.142</p>
<p>https://blog.csdn.net/CSDNwg/article/details/124355895</p>
<figure>
<img src="https://gitee.com/cj2564686478/note-img/raw/master/Img_Typora/202304102120553.png" alt="image-20230410212053478" /><figcaption aria-hidden="true">image-20230410212053478</figcaption>
</figure>
<p>算法的时间复杂度不仅与问题的规模有关，还与问题的其他因素有关。如某些排序的算法，其执行时间与待排序记录的初始状态有关。</p>
<p>递归的时间复杂度：</p>
<p>https://www.zhihu.com/question/63075755/answer/1151037825</p>
<h2 id="线性表">线性表</h2>
<h3 id="线性表的定义和基本操作">线性表的定义和基本操作</h3>
<ol start="2" type="1">
<li></li>
</ol>
<p>线性表的定义：数据特性相同的数据元素构成的有限序列称为线性表。</p>
<p>线性表的特点：除第一个之外，结构中的每个数据元素均只有一个前驱；除最后一个之外，结构中的每个数据元素均只有一个后继。</p>
<h3 id="线性表的顺序表示">线性表的顺序表示</h3>
<ol start="7" type="1">
<li><p>链表交换前需要查询第三个和第四个元素，而顺序表直接存取。</p></li>
<li><p>画图辅助（分析问题时用位序【从1开始】，实现用下标【从0开始】）</p></li>
</ol>
<h3 id="线性表的链式表示">线性表的链式表示</h3>
<ol start="4" type="1">
<li></li>
</ol>
<p><strong>V：队列需要在表头删除，表尾插入。所以选用带尾指针的循环链表（根据他的基本操作和结构特性进行选择）</strong></p>
<ol start="7" type="1">
<li></li>
</ol>
<p>数组排序的最好时间复杂度是nlogn，链表建立的时间复杂度是n（插入）所以T（n）=nlogn+n=nlogn</p>
<ol start="8" type="1">
<li></li>
</ol>
<p>找到尾节点后不用一个一个插入，直接让尾节点指向下一个节点的首个有值节点（将两个链表连接起来的时间复杂度为O（1））</p>
<ol start="18" type="1">
<li></li>
</ol>
<p>末尾插入节点需要找到末尾节点（尾指针）</p>
<p>删除末尾节点需要找到末尾节点的前一个节点（双向）</p>
<p>选择：</p>
<p>①：有头节点或者尾节点的链表</p>
<p>②：有头节点/尾节点的双循环链表</p>
<ol start="19" type="1">
<li></li>
</ol>
<ul>
<li>无法解决删除最后一个元素（尾节点前驱）</li>
<li>无法解决删除第一个元素和在第一个元素前插入（首节点前驱）</li>
<li></li>
<li>无法解决删除最后一个元素（尾节点前驱）</li>
</ul>
<ol start="23" type="1">
<li></li>
</ol>
<p>考虑非空和空的两种情况</p>
<p>总结：</p>
<p>双链表解决了寻找前驱的问题，循环链表（尾指针）解决了表头表尾插入的问题（无删除）</p>
<p>链表的痛点主要在于前驱</p>
<h2 id="栈队列和数组">栈、队列和数组</h2>
<h3 id="栈">栈</h3>
<ol start="3" type="1">
<li></li>
</ol>
<p>栈只可以在栈顶进行操作</p>
<ol start="7" type="1">
<li></li>
</ol>
<p>链表的插入和删除操作都在表头进行。当删除或着插入进行后，单链表要保持循环则需要尾指针指向头指针，但是C只有头指针，找到头指针需要O（n）。</p>
<p>这题的重点是能够找到头节点进行栈的相关操作，然后找到头节点和尾节进行指针域的修改以点保持链表的性质（单向循环和双向循环）</p>
<p><strong>单向循环链表通过尾指针才能体现其优势（表头表尾插入的时间复杂度为O（1））。</strong></p>
<p><strong>再次强调选择哪个数据结构合适一定要看它的基本操作和结构特性。</strong></p>
<ol start="11" type="1">
<li></li>
</ol>
<p>n和元素依次入栈，出栈的结果有： <span class="math display">\[
\frac{1}{n-1}C_{2n}^{n}
\]</span></p>
<ol start="12" type="1">
<li></li>
</ol>
<p>a b c d e f依次入栈，如果是d第一个出栈，那么说明a b c已经入栈。则出栈时至少有顺序为：c...b...a</p>
<p>推理：如果d在某一位置出栈，则除去其前面已出栈并入栈次序小于d的元素，然后至少有出栈顺序为入栈次序小于d的元素按入栈次序逆序的排序。</p>
<p>例如：</p>
<p>a b c d e f依次入栈，如果a第一个出栈，d第二个出栈。则至少有出栈顺序：a d...c...b</p>
<p>如果e出栈，说明，已经全部入栈（不管中途有没有入栈），此时清空栈，依次出栈，只有一种排序。</p>
<ol start="19" type="1">
<li></li>
</ol>
<p>标识符只能由字母、数字、下划线组成，第一个字符不能是数字。</p>
<ol start="26" type="1">
<li></li>
</ol>
<ul>
<li>斐波那契数列：</li>
</ul>
<p><span class="math display">\[
a_1=1,a_2=1,a_n=a_{n-1}+a_{n-2}\left( n&gt;3 \right)
\]</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i , f1=<span class="number">1</span>, f2=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">9</span>; i++)&#123;</span><br><span class="line">		<span class="type">int</span> t = f1;</span><br><span class="line">		f1=f2;</span><br><span class="line">		f2=t+f2;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,f2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>可以通过循环实现递归程序。</p>
<p>总结：</p>
<p>当出栈元素在某一个位置的时候，至少会存在某一形式的排列顺序。</p>
<ol start="29" type="1">
<li></li>
</ol>
<p>B：根据出栈顺序可以唯一确定入栈顺序。</p>
<h3 id="补充-2">补充：</h3>
<p>共享栈的优点：</p>
<p>https://www.zhihu.com/question/65253477/answer/2124666619</p>
<p>栈是在表头进行操作，是否可以在表尾工作（无头节点）：</p>
<p>即为啥是A而不是B：</p>
<figure>
<img src="https://gitee.com/cj2564686478/note-img/raw/master/Img_Typora/202304142251373.png" alt="2" /><figcaption aria-hidden="true">2</figcaption>
</figure>
<p>B：</p>
<p>Top指向尾节点，方便于插入，但是无法进行删除。</p>
<p>A：</p>
<p>Top指向首节点，方便于删除和插入。</p>
<h3 id="队列">队列</h3>
<ol start="6" type="1">
<li></li>
</ol>
<p>"已知循环队列的存储空间为数组A[21]"，对应代码int A[21]。所以最多存储21个元素。</p>
<ol start="9" type="1">
<li></li>
</ol>
<p>A：可以正常完成链队的插入和删除操作，但是对于B而言，A每次修改完后都要进行保持链表循环的操作。</p>
<ol start="12" type="1">
<li></li>
</ol>
<p>考虑当删除最后一个节点，rear=front</p>
<ol start="14" type="1">
<li></li>
</ol>
<p>有点难读懂，画个图：</p>
<figure>
<img src="https://gitee.com/cj2564686478/note-img/raw/master/Img_Typora/202304162034351.png" alt="4" /><figcaption aria-hidden="true">4</figcaption>
</figure>
<p>队尾插入时，需要找到队头，保持循环。但是只有头指针是已知的。所以为O（n）</p>
<ol start="15" type="1">
<li></li>
</ol>
<p>按照先进先出的规则，希望小号先出则大号需要排在小号后面，也就是小号先进队列，然后大号进入和小号同样的队列。</p>
<p>总结：</p>
<p>选择合适的数据结构的做题步骤：</p>
<ol type="1">
<li>首先看是否能够完成题目所要求的基本操作</li>
<li>能够完成基本操作情况下，比较保持选项自身数据结构特性操作的时间复杂度</li>
<li>以上两点都相同的话删除需要画蛇添足的选项（比如说带队首指针和队尾指针的非循环单链表就可以实现链队，你非要选择带队首指针和队尾指针的循环单链表，这样就多了需要保持循环的操作）</li>
</ol>
<p>链队的front指针负责删除，rear负责插入</p>
<p>当问到链表操作的时候一定要注意初始化和空、以及有无头节点这些特殊的情况。</p>
<p>双端队列关注受限制的那一段：</p>
<ol type="1">
<li>只有一端可入队</li>
</ol>
<p>通过q可以确定入队次序在q之前的元素在双端队列中的次序（排除掉已经出队的元素）。</p>
<p>【根据q出队，所以入队次序在q之前并且还未出队的元素一定按入队次序排列】</p>
<p>比如说1 4 2 3是否合法：</p>
<p>1进1出；4出说明2，3已进并且23还未出，则按照23排列；2，3，4进，4出，2出，3出。</p>
<ol start="2" type="1">
<li>只有一端可出队</li>
</ol>
<p>通过出队顺序和第一个元素可以排列出元素的在双端队列中大致的情况。</p>
<p>比如说3 1 4 2是否合法：</p>
<p>3出，说明1，2，3已进，根据输出顺序1先于2则，1进，2进（和1进去的端口不一样），3进，3出，1出；4进4出，2出。</p>
<ol start="3" type="1">
<li>解题思路：
<ol type="1">
<li>观察选项元素，判断哪些已进</li>
<li>观察选项，根据端口特性排序（一端口进可以直接排序，而一端口出需要考虑哪端进才能先出）</li>
<li>构造选项</li>
</ol></li>
</ol>
<h3 id="栈和队列的应用">栈和队列的应用</h3>
<ol start="10" type="1">
<li></li>
</ol>
<p>提取数据必须保持原来数据的顺序，符合队列先进先出的性质。</p>
<h2 id="树与二叉树">树与二叉树</h2>
<h3 id="树的基本概念">树的基本概念</h3>
<ol start="3" type="1">
<li></li>
</ol>
<p>路径长度是路径上所经过的边的个数，也就是路径上节点数-1。</p>
<p>树的路径长度是指树根到每个节点的路径长的总和</p>
<p>根到每个节点的路径长度的最大值为树的深度减1（一定是最深的叶子节点）</p>
<ol start="7" type="1">
<li></li>
</ol>
<p>叶子节点数=总节点数 - 有后继的节点（也就是有度的节点数）</p>
<h3 id="二叉树的概念">二叉树的概念</h3>
<ol start="2" type="1">
<li></li>
</ol>
<p>D：第i个节点的左孩子不一定存在。</p>
<ol start="6" type="1">
<li></li>
</ol>
<p>考虑总结点和各个度的节点之间的关系： <span class="math display">\[
\begin{cases}
    n=n_0+n_1+n_2\\
    n_{2=}n_0-1\\
\end{cases}
\]</span> 得出： <span class="math display">\[
n_1=2\left( n-n_0 \right) -1
\]</span> 所以n1为奇数，所以不能选择C</p>
<ol start="10" type="1">
<li></li>
</ol>
<p>第六层有叶子节点，考虑第六层为最后一层或为倒数第二层。要求节点数最少所以第六层为最后一层。</p>
<ol start="12" type="1">
<li></li>
</ol>
<p>根据总结点数可以求出其双亲节点，总结点数对应的编号为最后一个节点的编号，其双亲节点也为最后一个有子节点的节点。所以总结点编号减去双亲节点编号就得到叶子节点数。</p>
<ol start="13" type="1">
<li></li>
</ol>
<p>从第七层向下增加层数不会使第七层节点数增多，还会使可用节点变少（可加到第七层的节点）。所以第七层为最后一层。126-63=63刚好为第六层最后一层的子节点，<strong>无法从第六层抽出节点放到第七层（要注意满足n&lt;=2m【m为上层节点数】）</strong>。所以为63.</p>
<ol start="14" type="1">
<li></li>
</ol>
<p>法一：</p>
<figure>
<img src="https://gitee.com/cj2564686478/note-img/raw/master/Img_Typora/202305041157972.png" alt="1" /><figcaption aria-hidden="true">1</figcaption>
</figure>
<p>完全二叉树，假设叶子节点数为5，求最多有多少节点</p>
<p>假设倒数第二层叶子节点数为n</p>
<p>列出方程： <span class="math display">\[
7-n=\frac{7+\left( 5-n \right)}{2}
\]</span> 解出n=2。所以总结点数为（5-2）+7=10。</p>
<p>但是我们发现总结点数为9这种情况也符合条件：</p>
<p>4→5：叶子节点数-1</p>
<p>9→10：叶子节点数+1</p>
<p>叶子节点数为5，未变化！</p>
<p>说明这个方程无法解出全部答案。理由是根本无法满足方程：4！=9/2，所以这种情况会被忽略。</p>
<p>同理假设叶子节点数为6，解出n=1。总节点数为12，总结点数为11的情况被忽略。</p>
<p><strong>总结：</strong></p>
<p>方程只能计算出左子树，实际结果还应当包括左兄弟右子树。两者的叶子节点数一样多，但是总结点不一样多。方程求出的解总结点数更多，多1。</p>
<p>法二：n-n/2=124，n=248，同理这只能计算出左子树，实际结果还应当包括左兄弟右子树。两者的叶子节点数一样多，但是总结点不一样多。方程求出的解总结点数更多，多1。</p>
<ol start="16" type="1">
<li></li>
</ol>
<figure>
<img src="https://gitee.com/cj2564686478/note-img/raw/master/Img_Typora/202305041412062.png" alt="1" /><figcaption aria-hidden="true">1</figcaption>
</figure>
<p>假设h为最后一个节点所在的层数，n为最后一个节点的编号。则有： <span class="math display">\[
2^{h-1}\leqslant n\leqslant 2^h-1
\]</span> 对左不等式：</p>
<p>由于n比最后一层第一个节点大，所以算出来的h会偏大，我们下取整。 <span class="math display">\[
h=\lfloor \log _2n \rfloor+1
\]</span> 对右边不等式：</p>
<p>由于n比最后一层最后一个节点小，所以算出来的h会偏小，我们上取整。 <span class="math display">\[
h=\lceil \log _2\left( n+1 \right) \rceil 
\]</span> 这两个都可以算出正确答案。</p>
<ol start="19" type="1">
<li></li>
</ol>
<p>第六层有叶子节点，考虑第六层为最后一层或为倒数第二层。要求节点数最多所以第六层为倒数第二层。第六层8个叶子节点对应着第七层16个叶子节点。所以总结点：2^7-1-16=</p>
<ol start="20" type="1">
<li></li>
</ol>
<p>768/2=384，768-384=384</p>
<ol start="22" type="1">
<li></li>
</ol>
<p>二叉树的顺序存储一定要按照完全二叉树来存储，即空节点用0填充。只有这样，数组下标才可以和编号对应，从而反映节点的逻辑关系（通过编号找关系是完全二叉树的性质）。</p>
<p>但是对于一般二叉树而言，空节点较多，会浪费空间。所以顺序存储适合密度大的二叉树例如完全二叉树和满二叉树。</p>
<p>一般来说存储完最后一个节点，就不需要再存储了。</p>
<p>该题中：为了满足任意性，5层中所有的节点都需要存储。</p>
<p>总结：</p>
<p>常见题目：</p>
<ol type="1">
<li>给定节点数，求最小高度</li>
<li>给定高度，求最少节点</li>
<li>某一层有叶子节点，其可能是最后一层也可能是倒数第二层</li>
</ol>
<p>题目给出一个二叉树，不要自己带入完全二叉树或满二叉树，给定某一层时思考其是否为最后一层。</p>
<h3 id="二叉树的遍历和线索二叉树">二叉树的遍历和线索二叉树</h3>
<ol start="5" type="1">
<li></li>
</ol>
<p>m为n的祖先，使用二叉树的后序遍历可以找到m到n的路径。后序遍历为左右中。我们首先记录m，当在左子树中访问到n时可以全部出栈，当在右子树访问到n时左子树已经出栈只剩下路径节点。</p>
<ol start="6" type="1">
<li></li>
</ol>
<p>叶子节点一定是左右子树，而访问左右子树的顺序在三种遍历顺序中一样。</p>
<ol start="9" type="1">
<li></li>
</ol>
<p><strong>无左孩子或无右孩子都满足先序和后序遍历顺序相反</strong></p>
<ol start="13" type="1">
<li></li>
</ol>
<p><strong>只有先序和后序无法确定一颗二叉树，原因是无法确定左右子树，只能确定根节点（例如对于前序遍历序列和后序遍历序列相反的树其既可以左孩子为空，也可以右孩子为空）</strong></p>
<ol start="15" type="1">
<li></li>
</ol>
<p>先序或后序或层次确定根，中序确定左右</p>
<ol start="18" type="1">
<li></li>
</ol>
<p>二叉树是逻辑结构，线索二叉树是物理结构，因为一定要求是链式存储，指明了具体实现。</p>
<ol start="22" type="1">
<li></li>
</ol>
<p>D：非线索化先序无法找到前驱，后序无法找到后继</p>
<ol start="24" type="1">
<li></li>
</ol>
<p>D：不一定是叶子节点，例如没有右叶子结点的话就为中节点</p>
<ol start="26" type="1">
<li></li>
</ol>
<p>B等价于只有一个孩子</p>
<ol start="28" type="1">
<li></li>
</ol>
<p>可以先写出后序遍历序列，再根据序列的前后缀和图进行比对。</p>
<ol start="30" type="1">
<li></li>
</ol>
<p><strong>如果前序序列和后序序列相反，则每个节点都只有一个孩子。</strong></p>
<p>前序：a，e，b，d，c</p>
<p>后序：b，c，d，e，a</p>
<p>已知a为根节点，e及其后面的内容为左孩子和右孩子，假设前序遍历：ae【左孩子】x【右孩子】。如果右孩子不空的话则后序遍历为：axe，但是后序遍历序列中ae之间无内容所以a无右孩子。a和e确定了。现在确定e的子树。</p>
<p>假设前序遍历：ebx，则后续遍历：xbe。符合则e有左右孩子，b为左孩子，d有右孩子。剩下的c为d的左右孩子均可以。</p>
<ol start="33" type="1">
<li></li>
</ol>
<p>先序遍历操作和后序遍历操作唯一不同：先序在入栈时访问，后序在出栈时访问。因此通过先序遍历序列可以确定入栈序列，从而得出出栈有几种情况，从而得出中序序列有几种情况，一个先序和一个中序可以确定一棵树。</p>
<ol start="36" type="1">
<li></li>
</ol>
<p>​ 左 中 右</p>
<p>左中右 | 中 | 左中右</p>
<p>​ p q</p>
<p>D：p为左子树的右，q为上层中。</p>
<p>总结：</p>
<ol type="1">
<li><p>前序和后序相反，则为双亲节点和孩子节点（部分也行）</p></li>
<li><p>展开</p></li>
<li><p>先序对应入栈，中序对应出栈。<span class="math inline">\(\frac{1}{n+1}C_{2n}^{n}\)</span></p></li>
</ol>
<h3 id="树森林">树、森林</h3>
<ol start="6" type="1">
<li></li>
</ol>
<p>假设有这么一棵树T：</p>
<figure>
<img src="https://gitee.com/cj2564686478/note-img/raw/master/Img_Typora/202305151551822.png" alt="1" /><figcaption aria-hidden="true">1</figcaption>
</figure>
<p>其对应的二叉树B：</p>
<figure>
<img src="https://gitee.com/cj2564686478/note-img/raw/master/Img_Typora/202305151555772.png" alt="1" /><figcaption aria-hidden="true">1</figcaption>
</figure>
<p>比较后发现：B中右子树为空的节点有F、D、I、A。在T中观察这几个节点的特性发现这几个节点除了A以外都是某个子树的最后一个节点。例如D是A子树的最后一个节点，F是B子树最后一个节点，I是D子树最后一个节点。</p>
<p>因此一次右子树为空的节点的取值范围为：某一层子树中的最后一个子节点或者为根节点。如果为某一层子树中的最后一个子节点那么其唯一的父节点必定为非叶子节点。那么右子为空的节点数 = 非叶子节点数 + 1（1代表根节点。）</p>
<ol start="12" type="1">
<li></li>
<li></li>
</ol>
<p>在B中如果左孩子为空说明无子树即为叶子节点。</p>
<ol start="14" type="1">
<li></li>
</ol>
<p>对于任意一棵树，节点数 = 边数 + 1。对于森林来说，每一棵树都是独立的，如果加上一条边便可以让两个不同的树组成一颗新树，即满足：节点数 = 边数 + 1。因此对于森林来说多一棵树就需要多一条边来组成树。</p>
<p>因此有：森林节点数 = 森林边数 + 1 + 独立树棵树 - 1</p>
<h3 id="树与二叉树的应用">树与二叉树的应用</h3>
<ol start="4" type="1">
<li></li>
</ol>
<p>最多节点的哈夫曼树：</p>
<figure>
<img src="https://gitee.com/cj2564686478/note-img/raw/master/Img_Typora/202305152118094.png" alt="1" /><figcaption aria-hidden="true">1</figcaption>
</figure>
<p>对于递增的${ a_n } <span class="math inline">\(若每次\)</span>a_n<span class="math inline">\(和\)</span>a_{n+1}<span class="math inline">\(合成出的新节点\)</span>a_{n}<span class="math inline">\(大于\)</span>a_{n+3}<span class="math inline">\(将会导致\)</span>a_{n+2}<span class="math inline">\(和\)</span>a_{n+3}<span class="math inline">\(另外生成一个新的子树\)</span>a_{n+2}$（最多的情况下除了第一层和第二层每一层都是4个节点）</p>
<p>最少节点的哈夫曼树：</p>
<figure>
<img src="https://gitee.com/cj2564686478/note-img/raw/master/Img_Typora/202305152127743.png" alt="1" /><figcaption aria-hidden="true">1</figcaption>
</figure>
<p>除了第一层，每层两个节点</p>
<ol start="7" type="1">
<li></li>
</ol>
<p>根据节点数和边数可以列出方程： <span class="math display">\[
mn_m=n_0+n_m-1
\]</span></p>
<ol start="13" type="1">
<li></li>
</ol>
<p>因为要考虑多种可能性，我们采用饱和二叉树进行分析：</p>
<figure>
<img src="https://gitee.com/cj2564686478/note-img/raw/master/Img_Typora/202305152202183.png" alt="1" /><figcaption aria-hidden="true">1</figcaption>
</figure>
<p>A：10下面一定是5和5，不符合</p>
<p>B：10加12不等于24，不符合</p>
<p>C：最小应该3和10结合而不是11和3结合</p>
]]></content>
  </entry>
</search>
